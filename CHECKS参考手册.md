# CHECKS配置参考手册

## 概述
CHECKS是一个页面状态检测和自动响应系统，通过配置文件(`Checks.json`)定义检测规则和响应动作。主要用于自动化检测页面状态并执行相应操作，比如自动点击特定按钮、处理广告弹窗等。

CHECKS系统的核心功能：
- 自动检测屏幕上的文本和元素
- 根据预设规则执行点击、返回等操作
- 支持多层级检查器嵌套，构建复杂的自动化流程
- 可处理广告弹窗、每日签到、奖励领取等常见场景
- 支持临时检查器和守护进程模式，满足不同自动化需求
- 提供完整的命令行管理接口，方便动态调整配置
- 支持根据策略文件批量定时执行检查器任务

CHECKS系统适用场景：
- 应用自动化测试
- 日常任务自动处理
- 广告自动跳过
- 奖励自动领取
- 签到任务自动完成
- 页面状态监控与响应
- 定时执行重复性任务

## 配置项说明

### 1. name（名称）
- **功能**: 检查器的唯一标识
- **类型**: 字符串
- **必填**: 是
- **说明**: 
  - 会被自动转为小写存储
  - 如果没有设置匹配规则（match），name后面的部分会被默认用作匹配规则
  - 例如："top-发现" 中，"发现"会被用作默认匹配规则

### 2. match（匹配规则）
- **功能**: 指定检查器匹配屏幕内容的规则
- **类型**: 字符串
- **必填**: 否（默认使用name的后缀）
- **特性**:
  - 支持正则表达式
  - 支持使用 `&`（与）和 `|`（或）连接多个匹配条件
  - 可以指定匹配区域，例如：`任务中心(y0,300)` 表示在Y轴0到300的区域内匹配"任务中心"
  - 命令行添加：`+match 文本 [范围]`

### 3. childs（子检查器）
- **功能**: 指定当前检查器匹配成功后需要触发的子检查器列表
- **类型**: 字符串（逗号分隔的检查器名称列表）
- **必填**: 否
- **特性**:
  - 多个子检查器名称用逗号分隔，如 `-aa,haha,bb`
  - 当当前检查器匹配成功后，会异步触发这些子检查器
  - 用于构建检查器树，形成完整的交互流程
  - 子检查器会被并行启动，不相互阻塞
  - 父检查器退出时会自动停止所有子检查器
  - 命令行添加：`+childs 检查器名称` 或 `+checks 检查器名称`（兼容旧命令）

### 4. event（事件响应）
- **功能**: 指定匹配成功后要执行的操作
- **类型**: 字典对象，键为匹配条件，值为操作命令
- **必填**: 否
- **特性**:
  - **键（key）的类型**:
    - **普通文本匹配**: 当屏幕上出现该文本时触发，可以是正则表达式
    - **概率触发**: 以 `%` 开头，后跟数字，如 `%30` 表示有30%概率触发
    - **延时触发**: 以 `-` 开头，后跟数字，如 `-5` 表示延时5秒后触发
    - **无条件触发**: 空字符串 `""` 表示无条件执行一次
  - **值（value）是要执行的操作**:
    - 空值: 默认执行点击操作（对于文本匹配）或什么都不做（对于其他类型）
    - 单个操作: 如 `click`、`back`、`detect` 等
    - 多个操作: 以分号分隔，如 `"click;detect"`
    - 特殊指令: 
      - `this.end` 或 `exit`: 结束当前检查器，执行出口逻辑
      - `cancel`: 取消当前检查器执行，不执行出口逻辑
      - `->pageName`: 跳转到指定页面并取消当前检查器
  - 如果event为空且match不为空，默认会点击match匹配的元素
  - 命令行添加：`+event 匹配文本 操作命令`

### 5. entry（入口逻辑）
- **功能**: 指定进入检查器时需要执行的操作
- **类型**: 字典对象，键为页面名模式，值为执行代码
- **必填**: 否
- **特性**:
  - 键（key）是匹配当前页面名称的模式，支持正则表达式
  - 值（value）是要执行的代码
  - 通过enter()方法调用，会先匹配当前页面名，然后执行对应代码
  - 成功执行后会延时3秒再进行match匹配
  - 命令行添加：`+entry 页面名 操作代码`

### 6. exit（出口逻辑）
- **功能**: 指定检查器完成后的出口逻辑
- **类型**: 字符串
- **必填**: 否
- **特性**:
  - 可以是页面名，会通过gotoPage跳转到指定页面
  - 也可以是代码，会直接执行该代码
  - 在update()方法结束时执行
  - 命令行设置：`set exit 页面名/代码`

### 7. interval（检查间隔）
- **功能**: 指定检查的时间间隔
- **类型**: 整数（秒）
- **默认值**: 0
- **特性**:
  - 如果为0，则不会定期检查
  - 大于0时表示每隔多少秒检查一次
  - 命令行设置：`set interval 秒数`

### 8. timeout（超时时间）
- **功能**: 指定检查的最长等待时间
- **类型**: 整数（秒）
- **默认值**: 5
- **特性**:
  - 如果在timeout时间内未完成检查，则检查失败
  - 一些操作如广告等可能需要设置更长的timeout值
  - 在update()方法中用于控制循环超时退出
  - 命令行设置：`set timeout 秒数`

### 9. type（类型）
- **功能**: 指定检查器的类型
- **类型**: 字符串
- **默认值**: "once"
- **可选值**:
  - "once": 一次性检查，检查一次后删除
  - "temp": 临时检查器，不会被保存到配置文件中
  - "deamon": 守护进程模式，持续检查不会超时
  - 命令行设置：`set type 类型值`

## 事件处理机制详解

CHECKS系统的事件处理机制是其核心功能之一，通过event配置可以实现复杂的交互逻辑。

### 事件触发条件 (键值配置)

1. **文本匹配触发**
   ```json
   "点击领取": "click"
   ```
   当屏幕上出现"点击领取"文字时，执行点击操作。

2. **概率触发**
   ```json
   "%30": "@click(100,200)"
   ```
   有30%的概率执行点击坐标(100,200)的操作。这种配置在每次检查循环中只会被判断一次，无论是否执行都会标记为已处理。

3. **延时触发**
   ```json
   "-5": "back"
   ```
   延时5秒后执行返回操作。同样，这种配置在执行后会被标记为已处理，不会重复触发。

4. **无条件触发**
   ```json
   "": "detect"
   ```
   无条件执行一次应用检测操作。这在检查器启动时需要执行某些初始化操作时很有用。

### 事件执行操作 (值配置)

1. **基本操作**
   - `click`: 点击匹配的文本区域
   - `back`: 执行返回操作
   - `home`: 返回主页
   - `detect`: 检测当前应用

2. **复合操作**
   ```json
   "领取奖励": "click;detect"
   ```
   先点击"领取奖励"文本，然后执行应用检测。

3. **特殊指令**
   - `this.end` 或 `exit`: 结束当前检查器并执行出口逻辑
     ```json
     "领取成功": "this.end"
     ```
   - `cancel`: 取消当前检查器执行，不执行出口逻辑
     ```json
     "关闭应用": "cancel"
     ```
   - `->pageName`: 跳转到指定页面并取消当前检查器
     ```json
     "去商城": "->商城页面"
     ```

4. **自定义代码执行**
   ```json
   "特殊按钮": "@ T.longClick('按钮', 2000)"
   ```
   执行自定义的Python代码，这里是长按"按钮"2000毫秒。

### 事件状态跟踪

CHECKS系统会记录已执行过的事件，确保在一个检查循环中每个事件只被触发一次：

- 对于文本匹配事件：只有当文本匹配成功且执行后才会被标记为已处理
- 对于概率、延时和无条件事件：一旦被处理（无论是否实际执行）就会被标记为已处理

这种机制确保了事件不会在短时间内重复触发，提高了自动化流程的稳定性和可预测性。

## 示例配置

### 基础示例
```json
{
  "name": "看广告",
  "match": "观看广告|看广告",
  "event": {
    "观看广告": "click",
    "看广告": "click",
    "领取成功": "exit"
  },
  "entry": {
    "奖励页面": "{ T.waitForText('观看广告', 3) }"
  },
  "exit": "主页",
  "childs": "广告-跳过",
  "timeout": 40
}
```

### 高级事件处理示例
```json
{
  "name": "复杂任务处理",
  "match": "任务中心",
  "event": {
    "": "detect",                    // 无条件执行一次应用检测
    "-3": "@click(500,300)",         // 延时3秒后点击指定坐标
    "%50": "click;detect",           // 50%概率执行点击和检测
    "领取奖励": "click",             // 匹配"领取奖励"时点击
    "签到成功": "this.end",          // 匹配"签到成功"时结束检查器
    "去购物": "->商城页面",           // 匹配"去购物"时跳转到商城页面
    "关闭": "cancel"                 // 匹配"关闭"时取消检查器执行
  },
  "timeout": 60,
  "childs": "广告-跳过,弹窗处理"
}
```

这个配置展示了多种事件处理方式的组合使用，可以处理复杂的交互场景。

## 命令行操作指南

### 编辑检查器
```
#编辑 检查器名称
```

### 设置属性
```
#设置属性 属性名 属性值
示例: #设置属性 timeout 10
示例: #设置属性 exit 主页面
```

### 添加属性项
```
#+ 属性名 值 [附加值]
示例: #+ match 发现 100
示例: #+ childs 签到
示例: #+ event 点我领取 click
示例: #+ event %30 @click(100,200)  // 添加概率事件
示例: #+ event -5 back              // 添加延时事件
示例: #+ event "" detect            // 添加无条件事件
示例: #+ entry 广告页面 { T.click('开始观看') }
```

### 移除属性项
```
#- 属性名 值
示例: #- match 签到
示例: #- childs 签到
示例: #- event 点我领取
示例: #- event %30
示例: #- entry 广告页面
示例: #- exit
```

### 保存编辑
```
#结束编辑 [0|1]
```

### 执行检查
```
#检查 检查器名称
```

### 执行操作
```
#执行 检查器名称
```

### 测试入口逻辑
```
#测试入口 检查器名称
```

### 测试更新逻辑
```
#测试更新 检查器名称
```

### 查看所有检查器
```
#检查列表
```

### 显示检查器详情
```
#显示检查 检查器名称
```

### 删除检查器
```
#删除 检查器名称
```

## 批量执行功能

CHECKS系统支持通过策略配置文件批量执行检查器任务，实现定时、重复执行等高级自动化能力。

### 策略配置文件

策略配置文件`Policy.json`包含多个执行策略，每个策略定义一个检查器的执行计划。

#### 策略配置格式

```json
[
    {
        "checker": "检查器名称",
        "schedule": ["08:00", "20:00"],
        "days": [0, 1, 2, 3, 4, 5, 6],
        "times": 3,
        "duration": 0,
        "interval": 10
    }
]
```

#### 策略配置项说明

- **checker**（必填）: 要执行的检查器名称
- **schedule**（可选）: 定时执行计划，可以是单个时间字符串 "HH:MM" 或时间数组 ["HH:MM", ...]
- **days**（可选）: 星期几执行，数组[0-6]，0代表周一，6代表周日，默认所有天
- **times**（可选）: 每次执行的重复次数，设为0表示不限制次数
- **duration**（可选）: 每次执行的持续时间（秒），设为0表示不限制时间
- **interval**（可选）: 执行间隔（秒），默认5秒

### 执行模式

批量执行功能支持以下运行模式：

1. **定时执行模式**：根据schedule和days配置在指定时间执行任务
   ```json
   {
       "checker": "每日签到",
       "schedule": "08:00",
       "days": [1, 3, 5]
   }
   ```
   表示在每周一、三、五的上午8点执行"每日签到"检查器。

2. **次数限制模式**：在指定时间点执行指定次数
   ```json
   {
       "checker": "看广告",
       "schedule": ["12:00", "18:00"], 
       "times": 5,
       "interval": 30
   }
   ```
   表示在每天中午12点和晚上6点，执行"看广告"检查器5次，每次间隔30秒。

3. **时长限制模式**：在指定时间点执行指定时长
   ```json
   {
       "checker": "弹窗处理",
       "schedule": "09:00",
       "duration": 600,
       "interval": 5
   }
   ```
   表示在每天上午9点，执行"弹窗处理"检查器，持续600秒（10分钟），每次执行间隔5秒。

4. **即时执行模式**：不指定schedule，立即执行指定次数或时长
   ```json
   {
       "checker": "领取奖励",
       "times": 10,
       "interval": 60
   }
   ```
   表示立即执行"领取奖励"检查器10次，每次间隔60秒。

### 命令行使用方法

#### 执行指定策略文件中的所有任务
```
#策略执行 [策略文件路径]
```
路径可选，默认为`config/Policy.json`

#### 执行单个检查器的批量任务
```
#批量执行 检查器名称 次数 间隔秒数
```
例如：`#批量执行 每日签到 5 10` 表示执行"每日签到"检查器5次，每次间隔10秒。

## 工作原理

1. 通过enter()方法执行入口逻辑，匹配当前页面名，执行对应代码
2. 执行成功后，延时3秒进行match匹配
3. 匹配成功后，进入update()循环：
   - 循环中检测event匹配，执行对应操作
   - 每个事件只会被执行一次，系统会记录已执行的事件
   - 匹配childs列表中的子检查器，匹配成功则异步并行启动它们
   - 超时检测，超过timeout时间则退出循环
   - 父检查器退出时会自动停止所有子检查器
4. 循环结束后，执行出口逻辑exit，可能是跳转页面或执行代码

检查器通过enter()方法入口，Match()方法判断是否匹配，通过update()方法执行主循环，最后通过exit配置的出口逻辑完成全部流程。 